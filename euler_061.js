// Problem 61
// ==========
// 
// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
// are all figurate (polygonal) numbers and are generated by the following
// formulae:
// 
// Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
// Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
// Pentagonal   P[5,n]=n(3n-1)/2   1, 5, 12, 22, 35, ...
// Hexagonal    P[6,n]=n(2n-1)     1, 6, 15, 28, 45, ...
// Heptagonal   P[7,n]=n(5n-3)/2   1, 7, 18, 34, 55, ...
// Octagonal    P[8,n]=n(3n-2)     1, 8, 21, 40, 65, ...
// 
// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
// interesting properties.
// 
//  1. The set is cyclic, in that the last two digits of each number is the
//     first two digits of the next number (including the last number with
//     the first).
//  2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281),
//     and pentagonal (P[5,44]=2882), is represented by a different number in
//     the set.
//  3. This is the only set of 4-digit numbers with this property.
// 
// Find the sum of the only ordered set of six cyclic 4-digit numbers for
// which each polygonal type: triangle, square, pentagonal, hexagonal,
// heptagonal, and octagonal, is represented by a different number in the
// set.

function isPolygonal(n) {
	if(Number.isInteger((2 + Math.sqrt(12 * n + 4)) /  6)) {
		return 32;
	}
	if(Number.isInteger((3 + Math.sqrt(40 * n + 9)) / 10)) {
		return 16;
	}
	if(Number.isInteger((1 + Math.sqrt( 8 * n + 1)) /  4)) {
		return  8;
	}
	if(Number.isInteger((1 + Math.sqrt(24 * n + 1)) /  6)) {
		return  4;
	}
	if(Number.isInteger(     Math.sqrt(     n    )      )) {
		return  2;
	}
	if(Number.isInteger((1 + Math.sqrt( 8 * n + 1)) /  2)) {
		return  1;
	}
	return 0;
}

var parts = Array(6).fill(10);
var cycle, poly, i, sub;
outer: do {
	poly = Array(6);
	cycle = parts.map((c, i, a) => a[(i + a.length - 1) % a.length] * 100 + c);

	sub = 0;
	for(i = 0; i < 6; i++) {
		poly[i] = isPolygonal(cycle[i]);

		if(poly[i] == 0 && i > 0 && parts[i] < 99) {
			parts[i]++;
			continue outer;
		}
		
		sub |= poly[i];
	}
	
	if(i == 6 && sub == 63) {
		return(cycle.reduce((a, b) => a + b));
	}

	for(i = parts.length - 1; parts[i] == 99; i--) {
		parts[i] = 10;
	}
	if(i < 0) {
		parts[0] = 0;
	} else {
		parts[i]++;
	}

} while(parts[0] > 0);

return 0;
